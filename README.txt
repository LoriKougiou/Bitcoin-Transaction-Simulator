SYSPRO PROJECT 1--README
ΛΟΡΙ ΚΟΥΓΙΟΥΜΤΖΙΑΝ 		ΑΜ: 1115201400076

compile: make
run: ./bitcoin -h1 11 -h2 13 -b 300 -a balance -t trans -v 50 (τα νουμερα ειναι ενδεικτικα όπως και η σειρα των ορισματων)

Το project αποτελείται από τα παρακάτω αρχεία:
-main.c
-hash.c/hash.h
-bitcoin.c/bitcoin.h
-transaction.c/transaction.h
-Makefile

Στη main αφου γίνει το argument parsing και βεβαιωθούμε πώς έχει δοθεί σωστός αριθμός ορισμάτων, δημιουργούνται τα sender και receiver hashtables και αρχικοποιούντια με NULL.Στη συνέχεια διεκπαιρεώνονται οι συναλλαγές που είναι μέσα στο transaction file που έχει δοθεί ώς όρισμα. Αφού ολοκληρωθούν οι συναλλαγές του αρχείου, το πρόγραμμα διαβάζει από το stdin διάφορες εντολές και τις εκτελεί μέχρι να δοθεί η εντολή /exit με την οποία το πρόγραμμα ελευθερώνει όλη την δεσμευμέμη μνήμη και τερματίζει.

--bitcoin.c/bitcoin.h
Τα αρχεία αυτά περιέχουν τις δομές και τις συναρτήσεις που απαιτούνται για την δημιουργία, την αποθήκευση, τους ελέγχους και τη γενικότερη διαχείριση των bitcoins. Επίσης περιέχουν και τις δομές για το bitcoinhashtable το οποίο αποθηκεύει στη μορφή ευρετηρίου τα bitcoinIDs και τις ριζες των bitcoinTrees.
Ο λόγος που επέλεξα να κρατάω τα bitcoinIDs και τις ριζες τους σε hashtable είναι η γρήγορη αναζήτηση και προσπέλαση ενός bitcoinID, που επιταχύνει πολύ τη διαδικασία έλέγχου μοναδικότητας των IDs.Παρ'όλα αυτα, στα bucket records του bitcoinHash δε κρατούσα όλο το struct του κάθε bitcoin, αλλα μόνο το αναγνωριστικό και την ρίζα του δένδρου του, καθώς όταν αυτό θα συμμετάσχει σε κάποια συναλλάγη, και οι δύο χρήστες θα καταλήξουν να έχουν αύτο το bitcoin στη λίστα τους, όμως με διαφορετικό amount. Έτσι επέλεξα την υλοποίησ που έχω κάνει, δηλαδή όλοι οι κόμβοι του ίδιου bitcoin να δείχνουν στην ίδια εγγραφή του bitcoinHashTable, δηλαδή να μοιράζονται απο κοινού το δένδρο και το ID, αλλά να έχουν ξεχωριστούς ακέραιους που κρατούν το ποσό που έχουν.
Στο αρχείο υπάρχουν επίσης συναρτήσεις που δημιουργούν και ενημερώνουν ένα bitcointree, αναζητούν συγκεκριμένους κόμβους του, το εκτυπώνουν ανα επιπέδο και το καταστρέφουν. Επίσης υπάρχουν συναρτήσεις που υπολογίζουν το unspent ποσο του bitcoin, υπολογίζουν τα transactions στα οποία έχει συμμετάσχει και τα εκτυπώνουν.

--hash.c/hash.h
Τα αρχεία αυτά περιέχουν τις δομές και τις συναρτήσεις που απαιτούνται για την δημιουργία, την αποθήκευση, τους ελέγχους και τη γενικότερη διαχείριση των wallet της εφαρμογής, καθώς επίσης και τις δομές και τις συναρτήσεις για τα sender και receiver hashtables. Όπως ζητούσε η άσκηση, τα hashtables των receivers και senders έχουν buckets με entries που αφορούν τα wallets. Η υλοποίηση που έχω επιλέξει άποθηκεύει όλα τα wallets σε έναν array, και με βάση τα hash value που το καθένα αντιστοιχεί, τα bucketEntry του hashTable κρατάνε έναν ακέραιο που είναι το index του συγκεκιρμένου wallet στον array, και ένα transaction List με τις συναλλαγές στις οποίες το wallet έχει συμμετάσχει. Όλα τα υπ´ολοια δεδομένα του wallet (ID, balance, bitcoins) βρίσκονται στον array, και προσπελασσονται εύκολα μέσω του hashtable. 
Τα αρχεία αυτά περιέχουν συναρτήσεις δημιουργίας και αποθήκευσς των hashtable, εκτύπωσης τους, την hash function για τον κατακερματισμό, συβάρτηση ελέγχου μοναδικότητας του κάθε walletID, όπως επίσης και συναρτήσεις καταστροφής τν δομών και απελευθέρωσης της δεσμευμένης μνήμης.

--transaction.c/transaction.h
Τα αρχεία αυτά περιέχουν τις δομές και τις συναρτήσεις που απαιτούνται για την δημιουργία, την αποθήκευση, τους ελέγχους και τη γενικότερη διαχείριση των transactions, αλλα και του hashtable που έχω επιλέξω να δημιουργώ για την αποθήκευση και τον έλεγχο μοναδικότητας των transactionIDs. Αυτή τη φορά το hashtable κρατάει μόνο τα strings των transactionIDs, και όταν δεσμέυεται μια νέα δομή transaction στη λίστα ενός χρήστη, αφού έχει γίνει ο έλεγχος μοναδικότητας, ο το ID του κόμβου αυτού δείχει στην εγγραφή του hashtable, έτσι ώστε το κοινό transaction οτυ sender και του receiver να δείχνουν σε κοινό ID. Ο λόγος που δεν ακολούθησα την ίδια υλοποίηση στα transactions όπως είχα ακολούθήσει και στα wallets, δηλαδή έναν array, είναι ότι τα transactions αυξάνονται συνεχως και είναι ευκολότερο να βρίσκονται σε λίστες. Επίσης,ο λόγως που έχω επιλέξει το ίδιο transaction α δεσμέυεται στην λίστα και του sender και του receiver είναι ότι ανάλογα με τις συναλλαγές στις οποίες συμμετέχει ο κάθένας, το ίδιο αυτό transaction θα έχει άλλο next στη μία λίστα και άλλο next στην αλλη. Προς αποφυγήν μπερδεμάτων λοιπόν έπέλεξα αυτή την υλοποίηση.
Το αρχείο αυτό περιέχει τη συνάρτηση που παίρνει το transaction ως string, το κάνει parse και αφού ολοκληρώσει όλους τους ελέγχους ολοκληρώενι την συναλλαγή.Περιέχει επίσης συναρτήση που επιλέγουν ποιο bitcoin του χρήστη θα χρησιμοοποιηθεί κάθε φορα και επιλεγεται το πρωτο της λιστας του χρηστη, συνάρτηση που ελέγχει την εγκυρότητα μαις ημερομηνιάς και αποθηκεύει την ημερομηνία ως η πιο πρόσφατη, συνάρτηση που ελέγχει εάν το transactionID περιέχει μόνο ψηφία (χρησιμεύει για την έυρεση του max transactionID με αριθμούς και την αύξηση του κατα ένα για την ανάθεση νέων transactionID), συνάρτηση που ψάχνει και υπολογίζει τα payments/earnings ενός wallet, εκτυπώνει τα transactions και απελευθερώνει τη μνήμη που έχει δεσμευτεί για τις δομές.

'Οσον αφορα την requestTransactions, oοταν δεν δίνεται αρχείο η εντολή τερματίζει όταν δοθεί το αλφαριθμητικό done από το stdin. Στην περίπτωση που δίνεται αρχείο η υλοποίηση μου καλύπτει την ορφή αρχειόυ όπου κάθε transaction έχει στο τέλος ;\n. Με μόνο ; και χωρις αλλλαγής γραμμής η υλοποίηση μου θεωρεί τις συναλλαγές σε invalid format. 

Το πρόγραμμα αναπτύχθηκε σε περιβάλλον ubuntu 18.04, κάνει compile και τρέχει και στα μηχανήματα της σχολης.
